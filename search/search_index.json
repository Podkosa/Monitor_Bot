{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p> a monitoring bot for your servers </p> <p>Current features:</p> <ul> <li> Bot: HTTP-server for on-demand checks</li> <li> Watchdog: Compact daemon for monitoring and alerting</li> <li> Checkers: Ping, Celery/Flower, Docker containers (through SSH)</li> <li> Handlers: Slack, Webhook, Log, Console</li> <li> Integrations: Slack</li> <li> Speed: Async requests, Python 3.11, uvloop and FastAPI ensure the max gauge of your Python  speedometer</li> <li> Settings: Declarative YAML. Fine tune to your liking or fire-and-forget.</li> <li> Docker: Pull the latest image from podkosa/moni</li> <li> Docs: Moni Handbook. Interactive docs at /docs</li> </ul>"},{"location":"#bot","title":"Bot","text":"<p>HTTP server, handling incoming requests (REST, slash commands, integrations, webhooks etc.). On-demand checks.</p>"},{"location":"#watchdog","title":"Watchdog","text":"<p>Periodically monitors servers with Checkers and alerts through Handlers. Can be run in two ways:</p> <ol> <li>Integrated (default). Launch inside the bot async event loop. Keep in mind that they both will share a single thread, therefore can impact performance and even block one another. More compact option, but not fit for scaling.</li> <li>Standalone. Run <code>watchdog.py</code> as a separate process/container, even without the bot.</li> <li>Disabled. You can turn off the watchdog completely and run checks from the bot at your own pace.</li> </ol>"},{"location":"#settings","title":"Settings","text":"<p>Define your servers, handlers, integrations and other settings declaratively in <code>settings.yml</code>. See <code>example.settings.yml</code>.</p>"},{"location":"#integrations","title":"Integrations","text":"<ul> <li>Slack: alerts to channels and slash commands. Install Moni in your Workspace with <code>./integrations_docs/slack_app_manifest.yml</code>.</li> </ul>"},{"location":"#todo","title":"TODO","text":"<ul> <li>Telegram integration</li> <li>Email handler</li> <li>Slack timeout for /commands is 3 seconds. Refactor to delay the response.</li> <li>Slack button on an alert to open up related service</li> <li>Web interface for settings and checks</li> <li>Endpoint to show loaded checkers and handlers</li> <li>Endpoint to add servers to monitoring, turn on/off already configured ones</li> <li>More alert handlers</li> <li>More server checkers</li> <li>Proper loop exit</li> <li>Optional multiprocessing, when there will be more checkers</li> <li>Tests</li> </ul>"},{"location":"GettingStarted/","title":"Getting Started","text":"<p>Ideal way to run Moni would be to set it up somewhere outside of your servers, so it doesn't go down with your production servers and can actually alert if they are down. To run Moni in a container you need to:</p> <ol> <li>Create <code>settings.yml</code> and define necessary settings (see Settings section).</li> <li>Pull and run a Docker image from <code>podkosa/moni</code> Bash<pre><code>docker run -v /yourdirectory/settings.yml:/moni/settings.yml podkosa/moni\n</code></pre></li> </ol> <p>If you're familiar with Docker Compose see <code>example.docker-compose.yml</code> in the GitHub repo.</p>"},{"location":"bot/","title":"Bot","text":"<p>Moni Bot allows you to send HTTP GET requests to it's endpoints for on-demand checks. Response body will contain:</p> JSON<pre><code>{\n\"host\": str,\n\"check\": str,\n\"status\": bool,\n\"message\": str\n}\n</code></pre>"},{"location":"bot/Integrations/","title":"Integrations","text":"<p>Integrations allow you to run on-demand checks as slash commands from your favorite messenger.</p> <p>Integrations and Handlers</p> <p>Integrations are not to be confused with similar Handlers, used for alerts.</p>"},{"location":"bot/Integrations/#slack","title":"Slack","text":"<p>Install Moni as an App in your Slack Workspace to run slash commands. See <code>/integrations/slack_app_manifest.yml</code> in the GitHub repo.</p>"},{"location":"checkers/","title":"Checkers","text":"<p>Checkers are what Moni uses to monitor your servers. Define them in <code>settings.yml</code> in lowercase, provide necessary settings, list servers you want to monitor.</p>"},{"location":"checkers/Docker/","title":"Docker","text":"<p>Checks Docker containers status. Runs <code>docker ps -a --format ...</code> on your servers. Requires SSH (see Settings/SSH).</p> settings.yml<pre><code>checkers:\ndocker:\nservers:\nhost1.com:\n# port: 22\n# handlers: [...]\n# cycle: 300\nhost2_alias:\n</code></pre>"},{"location":"checkers/Flower/","title":"Flower","text":"<p>Checks workers status and queues sizes of your Celery server through Flower endpoints <code>flower/api/workers</code> and <code>flower/api/queues/length</code>.</p> settings.yml<pre><code>checkers:\nflower:\noptions:\nqueues:\nsize_threshold: 100\nworkers:\nservers:\nhost1.com:\nendpoint: path/to/ping/\nuser: user1\npassword: password1\n# handlers: [...]\n# cycle: 300\n</code></pre>"},{"location":"checkers/Ping/","title":"Ping","text":"<p>Basic Checker that sends an HTTP GET request to your server and alerts if the response is <code>4**</code>, <code>5**</code> or if it couldn't connect. Can do basic user-password authentication.</p> settings.yml<pre><code>checkers:\nping:\nservers:\nhost1.com:\nendpoint: path/to/ping/\n# user: user1\n# password: password1\n# handlers: [...]\n# cycle: 300\n</code></pre>"},{"location":"handlers/","title":"Handlers","text":"<p>Handlers are what Moni uses to send alerts. Define them in <code>settings.yml</code> in lowercase, provide necessary settings. In Checkers list what Handlers to use.</p>"},{"location":"handlers/Console/","title":"Console","text":"<p>Outputs alerts to STDOUT.</p> settings.yml<pre><code>handlers:\nconsole:\n</code></pre>"},{"location":"handlers/Log/","title":"Log","text":"<p>Writes alerts to a file in <code>/moni/logs</code> directory.</p> <p>Log size</p> <p>Rotation is not implemented yet, so be sure to clean up (e.g. with a <code>cron</code> periodic task)</p> <p>Containerization</p> <p>If you're deploying inside a container (e.g. Docker), be sure to mount <code>./logs/:/moni/logs</code> through <code>volumes</code></p> settings.yml<pre><code>handlers:\nlog:\nfilename: moni.log\n</code></pre>"},{"location":"handlers/Slack/","title":"Slack","text":"<p>Sends alerts to your Slack channel.</p> settings.yml<pre><code>handlers:\nslack:\nwebhook_url: https://hooks.slack.com/services/...\n</code></pre>"},{"location":"handlers/Webhook/","title":"Webhook","text":"<p>Sends a POST request to your url with check results.</p> JSON<pre><code>{\n\"host\": str,\n\"check\": str,\n\"status\": bool,\n\"message\": str\n}\n</code></pre> settings.yml<pre><code>handlers:\nwebhook:\nurl: http://your/webhook/url/\nuser: user\npassword: password\nheaders:\nheader1: header1\ncookies:\ncookie1: cookie1\n</code></pre>"},{"location":"settings/","title":"Settings","text":"<p>Main concept behind Moni is simplicity. For that, it uses declarative YAML settings. Choose what you like from Checkers, Handlers and Integrations, set up Bot/Watchdog and you're ready to go. Consult with <code>example.settings.yml</code> or follow up with an Example.</p>"},{"location":"settings/#basic-server-parameters","title":"Basic server parameters","text":"<p>Shared across all checkers are <code>cycle</code>, <code>handlers</code>, <code>protocol</code>, <code>port</code>, <code>back_to_normal</code>, <code>back_to_normal_cycle</code>.</p> <ul> <li><code>cycle</code>: <code>integer | float</code>     Seconds to wait between checks. Defaults to 300 seconds or 5 minutes. </li> </ul> <p>Precision</p> <p>Since Moni relies heavily on asynchronicity, this is implemented as a sleep between checks. For that, <code>cycle</code> is not absolute and may be slightly delayed by other running code.</p> <ul> <li> <p><code>handlers</code>: <code>list[str]</code>     List of handlers, through which alerts will be sent. For example <code>[console, log, slack]</code> will output to <code>STDOUT</code>, write to <code>./logs/moni.log</code>     and send a message to a Slack channel. Those 3 Handlers would have to be explicitly defined in the settings as well. </p> </li> <li> <p><code>protocol</code>: <code>http</code>, <code>https</code>     Protocol to use for the requests. Defaults to <code>https</code>. </p> </li> <li> <p><code>port</code>: <code>int</code>     Port to use for the requests. Defaults to not <code>None</code>, so 443(HTTPS) and 22(SSH) are used. </p> </li> <li> <p><code>back_to_normal</code>: <code>bool</code>     Optional \"back to normal\" messages. On a negative check alert normally, on further negative checks do not alert again, on a successful check send \"back to normal\" message. Defaults to <code>False</code>.</p> </li> <li> <p><code>back_to_normal_cycle</code>: <code>integer | float</code>     Optional back to normal follow up cycle. Set this to less than <code>cycle</code> to do follow up checks faster. Defaults to <code>cycle</code>. </p> </li> <li> <p><code>not_normal_for</code>: <code>integer</code>     Alert only when server check fails this number of cycles. Defaults to 1. </p> </li> </ul>"},{"location":"settings/#defaults","title":"Defaults","text":"<p>Default parameters might be specified to avoid repeating them for each server. Can be defined on a specific Checker or Global level. Lookup order is Server, Checker, Global.</p>"},{"location":"settings/#request-timeout","title":"Request timeout","text":"<p>You can set a custom timeout for Checkers requests to your servers. Default is: settings.yml<pre><code>request_timeout: 10\n</code></pre></p>"},{"location":"settings/#moni-self-alert","title":"Moni self alert","text":"<p>Moni can send messages when it is starting up or shutting down. settings.yml<pre><code>on_startup_handlers: [...]\non_shutdown_handlers: [...]\n</code></pre></p>"},{"location":"settings/#datetime-format","title":"Datetime format","text":"<p>For certain Handlers (like ConsoleHandler and LogHandler) a timestamp is used. You can customize the format. Default is: settings.yml<pre><code>dttm_format: '%Y-%m-%d %H:%M:%S'\n</code></pre></p>"},{"location":"settings/#logging","title":"Logging","text":"<p>If you want to make sure that you've set everything correctly and checks are actually running, you can set Moni internal logging level from default <code>info</code> to <code>debug</code>. settings.yml<pre><code>logger_level: debug\n</code></pre> And see something like: Bash Session<pre><code>Running PingChecker(podkosa.github.io)\nFinished PingChecker(podkosa.github.io)\n</code></pre></p>"},{"location":"settings/Example/","title":"Example","text":"<p>Let's say we need check every 5 seconds that podkosa.github.io/moni/ is up and returns a <code>2xx</code> response.  And if something is wrong, let's alert to standard <code>STDOUT</code>. Looks simple enough! For that we consulted our Moni Handbook and found a PingChecker and a ConsoleHandler. Let's create a <code>settings.yml</code> file in the project directory and fill it as we go.</p> <p>Security</p> <p>This file will include your sensitive data, so be sure to take security measures</p> <p>Containerization</p> <p>If you're deploying inside a container (e.g. Docker), be sure to mount <code>./settings.yml:/moni/settings.yml</code> through <code>volumes</code></p>"},{"location":"settings/Example/#api-key","title":"API key","text":"<p>Bot endpoints are protected with an API key. Pass it as a cookie, header or query parameter named <code>access_token</code> with you requests to Moni.</p> settings.yml<pre><code>api_key: key\n</code></pre> <p>Integrations</p> <p>Various integrations (like Slack and Telegram) use their own authentications methods and are not dependent on the Moni API key. Consult Integrations section for more info.</p>"},{"location":"settings/Example/#checker","title":"Checker","text":"<p>settings.yml<pre><code>checkers:\nping:\nservers:\nhost1.com:\nendpoint: path/to/ping/\nprotocol: 'https'\ncycle: 300\nhandlers: [console]\n</code></pre> Here we have a basic configurations of a Checker. Top level <code>checkers</code> must include named Checkers. For our example we chose a PingChecker, so we defined <code>ping</code>. Next we need to define our <code>servers</code>. They consist of key:value pairs that represent <code>host:config</code>.</p>"},{"location":"settings/Example/#handler","title":"Handler","text":"<p>Now let's define a Handler, so Moni knows how to alert you if something goes wrong. For this example we keep it simple and just print out to <code>STDOUT</code> with ConsoleHandler, so we simple defined <code>console</code>. This simple handler doesn't require additional settings, so let's move on. settings.yml<pre><code>handlers:\nconsole:\n</code></pre></p>"},{"location":"settings/Example/#watchdog","title":"Watchdog","text":"<p>With all of the above set, we have one last step to take (or rather one last  to throw). Defining our  Watchdog, that will run checks periodically. settings.yml<pre><code>watchdog:\nintegrated: true\n</code></pre></p> <p>Watchdog</p> <p>Consult Watchdog section for more details on this good pupper.</p>"},{"location":"settings/Example/#starting-up-moni","title":"Starting up Moni","text":"<p>All set! Just start up Moni and you'll see something like: Bash Session<pre><code>INFO:     Started server process [1]\nINFO:     Waiting for application startup.\nWatchdog is running\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://0.0.0.0:80 (Press CTRL+C to quit)\n</code></pre> Moni is up and Watchdog is already running your checks. When our host will not response, you'll see a message with details on what went wrong. Bash Session<pre><code>2022-10-31 12:00:00 PingChecker(podkosa.github.io) Cannot connect to host podkosa.github.io:443 ssl:default [Name or service not known]\n2022-10-31 12:05:00 PingChecker(podkosa.github.io) 404, message='Not Found', url=URL('https://podkosa.github.io/moni/')\n...\n</code></pre></p>"},{"location":"settings/SSH/","title":"SSH","text":"<p>Some checkers (like DockerChecker) use SSH. Configure your SSH access from Moni host to your servers as normal, then mount <code>.ssh/</code> directory to Moni container through a volume.</p> docker-compose.yml<pre><code>services:\nmoni:\nvolumes:\n- '~/.ssh/:/root/.ssh:ro'\n</code></pre>"},{"location":"settings/SSH/#unix-permissions","title":"UNIX permissions","text":"<p>Make sure that you set UNIX ownership/permissions, so that Moni container can read it. Bash<pre><code>chown root:$USER ~/.ssh/config\nchmod 644 ~/.ssh/config\nssh-add -k ~/.ssh/id_rsa\n</code></pre></p>"},{"location":"settings/SSH/#ssh-config-file","title":"SSH Config file","text":"<p>Recommend you to get familiar with <code>.ssh/config</code> and how to pre-set aliases for your connections. Moni accepts <code>Host</code> aliases as server's <code>host</code> setting and will use it's configs for connections. This is the recommended way.</p> <p>config<pre><code>Host host_alias\n  HostName your.host.com # or IP\n  User root\n  IdentityFile ~/.ssh/some_key.pub\n</code></pre> settings.yml<pre><code>checkers:\ndocker:\nservers:\nhost_alias:\n</code></pre></p>"}]}